# frozen_string_literal: true
api.array :heartables, api_meta(:total_count => @scope_count, :offset => @offset, :limit => @limit, :including_myself => !!params["including_myself"]) do
  hearts_grouped = Heart.hearts_to(@heartables).
   order(:created_at => :desc).
   preload(:user => :email_address).
   group_by { |v| [v.heartable_type, v.heartable_id] }
  @heartables.each do |heartable|
    hearts = hearts_grouped[[heartable.class.base_class.name, heartable.id]] || []
    api.heartable do
      hearted_users_count = hearts.length
      hearts = hearts.reject { |v| v[:user_id] == User.current.id } unless params["including_myself"]
      api.type heartable.class.base_class.name
      api.id heartable.id
      [:subject, :name, :title].each do |v|
        if heartable.respond_to?(v) && heartable.__send__(v).present?
          api.__send__ v, heartable.__send__(v)
          break
        end
      end
      api.project(:id => heartable.project.id, :name => heartable.project.name) if heartable.respond_to?(:project) && heartable.project.present?

      if heartable.respond_to?(:journalized_type) && heartable.journalized_type.present? &&
         heartable.respond_to?(:journalized_id) && heartable.journalized_id.present?
        api.journalized do
          api.type heartable.journalized_type
          api.id heartable.journalized_id
          api.note_index heartable.issue.journals.reorder(:created_on, :id).ids.index(heartable.id) + 1
        end
      end

      api.hearted_users_count hearted_users_count
      api.array :hearts do
        hearts.each do |heart|
          api.heart do
            api.user(:id => heart.user_id, :name => heart.user.name) unless heart.user.nil?
            api.created_at heart.created_at
          end
        end
      end
    end
  end
end
